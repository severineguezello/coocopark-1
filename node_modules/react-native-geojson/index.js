import React, { Component, PropTypes } from 'react';
import { View, Alert, Text, Image, Button } from 'react-native';
import MapView, {
  Marker,
  Callout,
  CalloutSubview,
  CustomCallout,
  ProviderPropType,
  Link
} from 'react-native-maps';
import uuid from 'uuid';
import parkIcon from '/Users/matthiasprevost/Documents/ReactNative/coocopark/media/small.png'
import { TouchableOpacity } from 'react-native-gesture-handler';
import { getProvidesAudioData } from 'expo/build/AR';



export const makeOverlays = (features) => {
  const points = features
    .filter(f => f.geometry && (f.geometry.type === 'Point' || f.geometry.type === 'MultiPoint'))
    .map(feature => makeCoordinates(feature).map(coordinates => makeOverlay(coordinates, feature)))
    .reduce(flatten, [])
    .map(overlay => ({ ...overlay, type: 'point' }));

  const lines = features
    .filter(
      f => f.geometry && (f.geometry.type === 'LineString' || f.geometry.type === 'MultiLineString')
    )
    .map(feature => makeCoordinates(feature).map(coordinates => makeOverlay(coordinates, feature)))
    .reduce(flatten, [])
    .map(overlay => ({ ...overlay, type: 'polyline' }));

  const multipolygons = features
    .filter(f => f.geometry && f.geometry.type === 'MultiPolygon')
    .map(feature => makeCoordinates(feature).map(coordinates => makeOverlay(coordinates, feature)))
    .reduce(flatten, []);

  const polygons = features
    .filter(f => f.geometry && f.geometry.type === 'Polygon')
    .map(feature => makeOverlay(makeCoordinates(feature), feature))
    .reduce(flatten, [])
    .concat(multipolygons)
    .map(overlay => ({ ...overlay, type: 'polygon' }));

  const overlays = points.concat(lines).concat(polygons);

  return overlays;
};

const flatten = (prev, curr) => prev.concat(curr);

const makeOverlay = (coordinates, feature) => {
  let overlay = {
    feature,
    id: feature.id ? feature.id : uuid(),
  };
  if (feature.geometry.type === 'Polygon' || feature.geometry.type === 'MultiPolygon') {
    overlay.coordinates = coordinates[0];
    if (coordinates.length > 1) {
      overlay.holes = coordinates.slice(1);
    }
  } else {
    overlay.coordinates = coordinates;
  }
  return overlay;
};

const makePoint = c => ({ latitude: c[1], longitude: c[0] });

const makeLine = l => l.map(makePoint);

const makeCoordinates = feature => {
  const g = feature.geometry;
  if (g.type === 'Point') {
    return [makePoint(g.coordinates)];
  } else if (g.type === 'MultiPoint') {
    return g.coordinates.map(makePoint);
  } else if (g.type === 'LineString') {
    return [makeLine(g.coordinates)];
  } else if (g.type === 'MultiLineString') {
    return g.coordinates.map(makeLine);
  } else if (g.type === 'Polygon') {
    return g.coordinates.map(makeLine);
  } else if (g.type === 'MultiPolygon') {
    return g.coordinates.map(p => p.map(makeLine));
  } else {
    return [];
  }
};



const textColor = (id,f) => {
  if(id!=6){
    if (f[id]['AVAILABLE_SPOTS']=="Parking COMPLET"){
      return 'red'
    }else{return 'rgb(0,100,178)'}
  }
  else {return 'black'}
  

}


const Avaibilities = (name, g) => {
  if (name == "Coat-ar-Gueven" && g!=null){
    return g[0]['AVAILABLE_SPOTS'];
  }else if (name == "Jaurès" && g!=null){
    return g[1]['AVAILABLE_SPOTS'];
  }else if (name == "Liberté" && g!=null){
    return g[2]['AVAILABLE_SPOTS'];
  }else if (name == "Enclos Sangnier" && g!=null){
    return g[3]['AVAILABLE_SPOTS'];
  }else if (name == "Enclos Gares" && g!=null){
    return g[4]['AVAILABLE_SPOTS'];
  }else if (name == "Enclos Château" && g!=null){
    return g[5]['AVAILABLE_SPOTS'];
  }
  else {return " ";}
}

const dataLoaded = j => {
  if (j.length!=0){
    return j
  }
  else{return null}
}

const getId = nom => {
  if (nom == "Coat-ar-Gueven"){
    return 0;
  }else if (nom == "Jaurès"){
    return 1;
  }else if (nom == "Liberté"){
    return 2;
  }else if (nom == "Enclos Sangnier"){
    return 3;
  }else if (nom == "Enclos Gares"){
    return 4;
  }else if (nom == "Enclos Château"){
    return 5;
  }
  else{return 6}
}

const preferences = (ident,props,overlay) => {
  if textColor(ident,dataLoaded(props.data))!== "red"){
    return false;
  }
  with open('/Users/Nassim/Desktop/preferences.json') as pref_data:
    pref=json.load(pref_data);
    const pmr = pref.PMR;
    const free = pref.FREE;
    if (overlay.feature.properties.PAIEMENT!="GRATUIT" && free){
      return false
    }
    else if (overlay.feature.properties.PMR==0 && pmr){
      return false
    }
  // Si l'on souhaite tester avec la hauteur on pourrait prendre la hauteur typique du véhicule utilisé puis créer une constante h qui continedrait la hauteur en fonction du type de véhicule et on mettrait une limite de hauteur à DEP_STA_PARKINGS.json
    else{
      return true
    }


const Geojson = props => {
  const overlays = makeOverlays(props.geojson.features);
  //console.log(props.geojson.features[0].properties.NOM);
  return (
    //console.log(dataLoaded(props.data)),
    <View>
      {overlays.map(overlay => {
        let ident = getId(overlay.feature.properties.NOM);
        if (overlay.type === 'point' && preference(ident,props,overlay)) {
          //console.log(typeof overlay.feature.properties.NOM); //{Avaibilities(overlay.feature.properties.NOM,dataLoaded(props.data))}
          return (
            <MapView.Marker
              key={overlay.id}
              coordinate={overlay.coordinates}
              pinColor={props.color}
              image={parkIcon}>
                <MapView.Callout
                onPress={() => console.log('pressed')}>
                  <Text style={{fontWeight : 'bold'}}>{overlay.feature.properties.NOM}</Text>
                  <Text style={{color : textColor(ident,dataLoaded(props.data))}}>{Avaibilities(overlay.feature.properties.NOM,dataLoaded(props.data))}</Text>
                  <Text>Places : {overlay.feature.properties.OFFRE} - PMR : {overlay.feature.properties.PMR}</Text>
                  <Text>{overlay.feature.properties.STATUT} </Text>
                  <Button title="Y aller" onPress={() => openurl(maps.apple:overlay.coordinates[0],overlay.coordinates[1])} />


                </MapView.Callout>
              </MapView.Marker>

          );
        }
        if (overlay.type === 'polygon') {
          return (
            <MapView.Polygon
              key={overlay.id}
              coordinates={overlay.coordinates}
              holes={overlay.holes}
              strokeColor={props.strokeColor}
              fillColor={props.fillColor}
              strokeWidth={props.strokeWidth}
            />
          );
        }
        if (overlay.type === 'polyline') {
          return (
            <MapView.Polyline
              key={overlay.id}
              coordinates={overlay.coordinates}
              strokeColor={props.strokeColor}
              strokeWidth={props.strokeWidth}
            />
          );
        }

      
      })}
    </View>
  );
};

export default Geojson;
